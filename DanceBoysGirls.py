 

#Бал в БерлГУ
#По случаю летия Берляндского государственного университета совсем скоро состоится бал! Уже n юношей и m девушек во всю репетируют вальс, менуэт, полонез и кадриль.

#Известно, что на бал будут приглашены несколько пар юноша-девушка, причем уровень умений танцевать партнеров в каждой паре должен отличаться не более чем на единицу.

#Для каждого юноши известен уровень его умения танцевать. Аналогично, для каждой девушки известен уровень ее умения танцевать. Напишите программу, которая определит наибольшее количество пар, которое можно образовать из n юношей и m девушек.

#Входные данные
#В первой строке записано целое число n (1 ≤ n ≤ 100) — количество юношей. Вторая строка содержит последовательность a1, a2, ..., an (1 ≤ ai ≤ 100), где ai — умение танцевать i-го юноши.

#Аналогично, третья строка содержит целое m (1 ≤ m ≤ 100) – количество девушек. В четвертой строке содержится последовательность b1, b2, ..., bm (1 ≤ bj ≤ 100), где bj — умение танцевать j-й девушки.

#Выходные данные
#Выведите единственное число — искомое максимальное возможное количество пар.

# Алгоритм 2х укзателей:
#Алгоритм двух указателей — это эффективный метод решения задач на массивах или строках (обычно отсортированных), использующий два индекса для одновременного обхода структуры данных за один проход (\(O(n)\)). Указатели двигаются навстречу, в одном направлении или с разной скоростью, что позволяет находить пары, подстроки или элементы, удовлетворяющие условиям. Основные типы и применение: Навстречу друг другу (с краев): Используется для поиска пар в отсортированном массиве (например, сумма элементов равна \(X\)), разворота массива или проверки палиндрома.В одном направлении (скользящее окно):
#Применяется для поиска подотрезков, удовлетворяющих условию, удаления дубликатов, или задачи "быстрый и медленный указатель". Преимущества: Сложность: \(O(n)\) времени, \(O(1)\) дополнительной памяти.Эффективность: Заменяет вложенные циклы (\(O(n^{2})\)) на один проход. 

# Зачем сортировка:
#Сортировка списков boys и girls необходима для применения алгоритма двух указателей (two pointers). Это позволяет за один проход (\(O(N\log N+M\log M)\)) найти максимальное количество пар с разницей в умении \(\le 1\), сравнивая только ближайшие по уровню пары и двигаясь от слабых к сильным, что невозможно в неупорядоченных данных. Почему нужна сортировка: Эффективность (Жадный алгоритм): Сортировка позволяет сопоставлять самых слабых юношей с самыми слабыми девушками, подходящими по уровню. Если пара не складывается, мы точно знаем, кого "отбросить" (более слабого), не перебирая все варианты.
#Указатели \(i\) и \(j\): Указатели могут корректно двигаться только в одном направлении, если списки упорядочены по возрастанию умений.Условие if abs(boys[i] - girls[j]) <= 1: Если разница большая, сортировка гарантирует, что \(boys[i]\) или \(girls[j]\) (меньший из них) не подойдет и к последующим элементам, поэтому можно безопасно сдвинуть указатель. Если не отсортировать данные, алгоритм пропустит возможные пары

n = int(input())
boys = sorted(list(map(int, input().split())))
m = int(input())
girls = sorted(list(map(int, input().split())))

i = 0  # указатель на юношей
j = 0  # указатель на девушек
pairs = 0
# Проходим по обоим отсортированным спискам
while i < n and j < m:
        # Если разница в умениях <= 1, пара найдена
        if abs(boys[i] - girls[j]) <= 1:
            pairs += 1
            i += 1
            j += 1
        # Если юноша танцует хуже, берем следующего юношу
        elif boys[i] < girls[j]:
            i += 1
        # Если девушка танцует хуже, берем следующую девушку
        else:
            j += 1

print(pairs)
